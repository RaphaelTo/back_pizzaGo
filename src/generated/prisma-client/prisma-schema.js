module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateCategory {
  count: Int!
}

type AggregateDessert {
  count: Int!
}

type AggregateDrink {
  count: Int!
}

type AggregateOrder {
  count: Int!
}

type AggregatePizza {
  count: Int!
}

type AggregatePromo {
  count: Int!
}

type AggregateSize {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Category {
  id: ID!
  name: String!
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge]!
  aggregate: AggregateCategory!
}

input CategoryCreateInput {
  id: ID
  name: String!
}

input CategoryCreateOneInput {
  create: CategoryCreateInput
  connect: CategoryWhereUniqueInput
}

type CategoryEdge {
  node: Category!
  cursor: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type CategoryPreviousValues {
  id: ID!
  name: String!
}

type CategorySubscriptionPayload {
  mutation: MutationType!
  node: Category
  updatedFields: [String!]
  previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CategoryWhereInput
  AND: [CategorySubscriptionWhereInput!]
  OR: [CategorySubscriptionWhereInput!]
  NOT: [CategorySubscriptionWhereInput!]
}

input CategoryUpdateDataInput {
  name: String
}

input CategoryUpdateInput {
  name: String
}

input CategoryUpdateManyMutationInput {
  name: String
}

input CategoryUpdateOneInput {
  create: CategoryCreateInput
  update: CategoryUpdateDataInput
  upsert: CategoryUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CategoryWhereUniqueInput
}

input CategoryUpsertNestedInput {
  update: CategoryUpdateDataInput!
  create: CategoryCreateInput!
}

input CategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
}

input CategoryWhereUniqueInput {
  id: ID
}

scalar DateTime

type Dessert {
  id: ID!
  price: Float!
  name: String!
  img: String!
}

type DessertConnection {
  pageInfo: PageInfo!
  edges: [DessertEdge]!
  aggregate: AggregateDessert!
}

input DessertCreateInput {
  id: ID
  price: Float!
  name: String!
  img: String!
}

type DessertEdge {
  node: Dessert!
  cursor: String!
}

enum DessertOrderByInput {
  id_ASC
  id_DESC
  price_ASC
  price_DESC
  name_ASC
  name_DESC
  img_ASC
  img_DESC
}

type DessertPreviousValues {
  id: ID!
  price: Float!
  name: String!
  img: String!
}

type DessertSubscriptionPayload {
  mutation: MutationType!
  node: Dessert
  updatedFields: [String!]
  previousValues: DessertPreviousValues
}

input DessertSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DessertWhereInput
  AND: [DessertSubscriptionWhereInput!]
  OR: [DessertSubscriptionWhereInput!]
  NOT: [DessertSubscriptionWhereInput!]
}

input DessertUpdateInput {
  price: Float
  name: String
  img: String
}

input DessertUpdateManyMutationInput {
  price: Float
  name: String
  img: String
}

input DessertWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  img: String
  img_not: String
  img_in: [String!]
  img_not_in: [String!]
  img_lt: String
  img_lte: String
  img_gt: String
  img_gte: String
  img_contains: String
  img_not_contains: String
  img_starts_with: String
  img_not_starts_with: String
  img_ends_with: String
  img_not_ends_with: String
  AND: [DessertWhereInput!]
  OR: [DessertWhereInput!]
  NOT: [DessertWhereInput!]
}

input DessertWhereUniqueInput {
  id: ID
}

type Drink {
  id: ID!
  price: Float!
  name: String!
  oz: Float!
  img: String!
}

type DrinkConnection {
  pageInfo: PageInfo!
  edges: [DrinkEdge]!
  aggregate: AggregateDrink!
}

input DrinkCreateInput {
  id: ID
  price: Float!
  name: String!
  oz: Float!
  img: String!
}

type DrinkEdge {
  node: Drink!
  cursor: String!
}

enum DrinkOrderByInput {
  id_ASC
  id_DESC
  price_ASC
  price_DESC
  name_ASC
  name_DESC
  oz_ASC
  oz_DESC
  img_ASC
  img_DESC
}

type DrinkPreviousValues {
  id: ID!
  price: Float!
  name: String!
  oz: Float!
  img: String!
}

type DrinkSubscriptionPayload {
  mutation: MutationType!
  node: Drink
  updatedFields: [String!]
  previousValues: DrinkPreviousValues
}

input DrinkSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DrinkWhereInput
  AND: [DrinkSubscriptionWhereInput!]
  OR: [DrinkSubscriptionWhereInput!]
  NOT: [DrinkSubscriptionWhereInput!]
}

input DrinkUpdateInput {
  price: Float
  name: String
  oz: Float
  img: String
}

input DrinkUpdateManyMutationInput {
  price: Float
  name: String
  oz: Float
  img: String
}

input DrinkWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  oz: Float
  oz_not: Float
  oz_in: [Float!]
  oz_not_in: [Float!]
  oz_lt: Float
  oz_lte: Float
  oz_gt: Float
  oz_gte: Float
  img: String
  img_not: String
  img_in: [String!]
  img_not_in: [String!]
  img_lt: String
  img_lte: String
  img_gt: String
  img_gte: String
  img_contains: String
  img_not_contains: String
  img_starts_with: String
  img_not_starts_with: String
  img_ends_with: String
  img_not_ends_with: String
  AND: [DrinkWhereInput!]
  OR: [DrinkWhereInput!]
  NOT: [DrinkWhereInput!]
}

input DrinkWhereUniqueInput {
  id: ID
}

scalar Json

scalar Long

type Mutation {
  createCategory(data: CategoryCreateInput!): Category!
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateManyCategories(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload!
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
  createDessert(data: DessertCreateInput!): Dessert!
  updateDessert(data: DessertUpdateInput!, where: DessertWhereUniqueInput!): Dessert
  updateManyDesserts(data: DessertUpdateManyMutationInput!, where: DessertWhereInput): BatchPayload!
  upsertDessert(where: DessertWhereUniqueInput!, create: DessertCreateInput!, update: DessertUpdateInput!): Dessert!
  deleteDessert(where: DessertWhereUniqueInput!): Dessert
  deleteManyDesserts(where: DessertWhereInput): BatchPayload!
  createDrink(data: DrinkCreateInput!): Drink!
  updateDrink(data: DrinkUpdateInput!, where: DrinkWhereUniqueInput!): Drink
  updateManyDrinks(data: DrinkUpdateManyMutationInput!, where: DrinkWhereInput): BatchPayload!
  upsertDrink(where: DrinkWhereUniqueInput!, create: DrinkCreateInput!, update: DrinkUpdateInput!): Drink!
  deleteDrink(where: DrinkWhereUniqueInput!): Drink
  deleteManyDrinks(where: DrinkWhereInput): BatchPayload!
  createOrder(data: OrderCreateInput!): Order!
  updateOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateManyOrders(data: OrderUpdateManyMutationInput!, where: OrderWhereInput): BatchPayload!
  upsertOrder(where: OrderWhereUniqueInput!, create: OrderCreateInput!, update: OrderUpdateInput!): Order!
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteManyOrders(where: OrderWhereInput): BatchPayload!
  createPizza(data: PizzaCreateInput!): Pizza!
  updatePizza(data: PizzaUpdateInput!, where: PizzaWhereUniqueInput!): Pizza
  updateManyPizzas(data: PizzaUpdateManyMutationInput!, where: PizzaWhereInput): BatchPayload!
  upsertPizza(where: PizzaWhereUniqueInput!, create: PizzaCreateInput!, update: PizzaUpdateInput!): Pizza!
  deletePizza(where: PizzaWhereUniqueInput!): Pizza
  deleteManyPizzas(where: PizzaWhereInput): BatchPayload!
  createPromo(data: PromoCreateInput!): Promo!
  updatePromo(data: PromoUpdateInput!, where: PromoWhereUniqueInput!): Promo
  updateManyPromoes(data: PromoUpdateManyMutationInput!, where: PromoWhereInput): BatchPayload!
  upsertPromo(where: PromoWhereUniqueInput!, create: PromoCreateInput!, update: PromoUpdateInput!): Promo!
  deletePromo(where: PromoWhereUniqueInput!): Promo
  deleteManyPromoes(where: PromoWhereInput): BatchPayload!
  createSize(data: SizeCreateInput!): Size!
  updateSize(data: SizeUpdateInput!, where: SizeWhereUniqueInput!): Size
  updateManySizes(data: SizeUpdateManyMutationInput!, where: SizeWhereInput): BatchPayload!
  upsertSize(where: SizeWhereUniqueInput!, create: SizeCreateInput!, update: SizeUpdateInput!): Size!
  deleteSize(where: SizeWhereUniqueInput!): Size
  deleteManySizes(where: SizeWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Order {
  id: ID!
  price: Float!
  date: DateTime!
  status: Float!
  user: User
  content: Json!
  promo: Promo
}

type OrderConnection {
  pageInfo: PageInfo!
  edges: [OrderEdge]!
  aggregate: AggregateOrder!
}

input OrderCreateInput {
  id: ID
  price: Float!
  status: Float
  user: UserCreateOneInput
  content: Json!
  promo: PromoCreateOneInput
}

type OrderEdge {
  node: Order!
  cursor: String!
}

enum OrderOrderByInput {
  id_ASC
  id_DESC
  price_ASC
  price_DESC
  date_ASC
  date_DESC
  status_ASC
  status_DESC
  content_ASC
  content_DESC
}

type OrderPreviousValues {
  id: ID!
  price: Float!
  date: DateTime!
  status: Float!
  content: Json!
}

type OrderSubscriptionPayload {
  mutation: MutationType!
  node: Order
  updatedFields: [String!]
  previousValues: OrderPreviousValues
}

input OrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderWhereInput
  AND: [OrderSubscriptionWhereInput!]
  OR: [OrderSubscriptionWhereInput!]
  NOT: [OrderSubscriptionWhereInput!]
}

input OrderUpdateInput {
  price: Float
  status: Float
  user: UserUpdateOneInput
  content: Json
  promo: PromoUpdateOneInput
}

input OrderUpdateManyMutationInput {
  price: Float
  status: Float
  content: Json
}

input OrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  status: Float
  status_not: Float
  status_in: [Float!]
  status_not_in: [Float!]
  status_lt: Float
  status_lte: Float
  status_gt: Float
  status_gte: Float
  user: UserWhereInput
  promo: PromoWhereInput
  AND: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
}

input OrderWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Pizza {
  id: ID!
  name: String!
  img: String!
  composition: Json!
  category: Category
}

type PizzaConnection {
  pageInfo: PageInfo!
  edges: [PizzaEdge]!
  aggregate: AggregatePizza!
}

input PizzaCreateInput {
  id: ID
  name: String!
  img: String!
  composition: Json!
  category: CategoryCreateOneInput
}

type PizzaEdge {
  node: Pizza!
  cursor: String!
}

enum PizzaOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  img_ASC
  img_DESC
  composition_ASC
  composition_DESC
}

type PizzaPreviousValues {
  id: ID!
  name: String!
  img: String!
  composition: Json!
}

type PizzaSubscriptionPayload {
  mutation: MutationType!
  node: Pizza
  updatedFields: [String!]
  previousValues: PizzaPreviousValues
}

input PizzaSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PizzaWhereInput
  AND: [PizzaSubscriptionWhereInput!]
  OR: [PizzaSubscriptionWhereInput!]
  NOT: [PizzaSubscriptionWhereInput!]
}

input PizzaUpdateInput {
  name: String
  img: String
  composition: Json
  category: CategoryUpdateOneInput
}

input PizzaUpdateManyMutationInput {
  name: String
  img: String
  composition: Json
}

input PizzaWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  img: String
  img_not: String
  img_in: [String!]
  img_not_in: [String!]
  img_lt: String
  img_lte: String
  img_gt: String
  img_gte: String
  img_contains: String
  img_not_contains: String
  img_starts_with: String
  img_not_starts_with: String
  img_ends_with: String
  img_not_ends_with: String
  category: CategoryWhereInput
  AND: [PizzaWhereInput!]
  OR: [PizzaWhereInput!]
  NOT: [PizzaWhereInput!]
}

input PizzaWhereUniqueInput {
  id: ID
}

type Promo {
  id: ID!
  name: String!
  amount: Int!
}

type PromoConnection {
  pageInfo: PageInfo!
  edges: [PromoEdge]!
  aggregate: AggregatePromo!
}

input PromoCreateInput {
  id: ID
  name: String!
  amount: Int!
}

input PromoCreateOneInput {
  create: PromoCreateInput
  connect: PromoWhereUniqueInput
}

type PromoEdge {
  node: Promo!
  cursor: String!
}

enum PromoOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  amount_ASC
  amount_DESC
}

type PromoPreviousValues {
  id: ID!
  name: String!
  amount: Int!
}

type PromoSubscriptionPayload {
  mutation: MutationType!
  node: Promo
  updatedFields: [String!]
  previousValues: PromoPreviousValues
}

input PromoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PromoWhereInput
  AND: [PromoSubscriptionWhereInput!]
  OR: [PromoSubscriptionWhereInput!]
  NOT: [PromoSubscriptionWhereInput!]
}

input PromoUpdateDataInput {
  name: String
  amount: Int
}

input PromoUpdateInput {
  name: String
  amount: Int
}

input PromoUpdateManyMutationInput {
  name: String
  amount: Int
}

input PromoUpdateOneInput {
  create: PromoCreateInput
  update: PromoUpdateDataInput
  upsert: PromoUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PromoWhereUniqueInput
}

input PromoUpsertNestedInput {
  update: PromoUpdateDataInput!
  create: PromoCreateInput!
}

input PromoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  AND: [PromoWhereInput!]
  OR: [PromoWhereInput!]
  NOT: [PromoWhereInput!]
}

input PromoWhereUniqueInput {
  id: ID
}

type Query {
  category(where: CategoryWhereUniqueInput!): Category
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category]!
  categoriesConnection(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CategoryConnection!
  dessert(where: DessertWhereUniqueInput!): Dessert
  desserts(where: DessertWhereInput, orderBy: DessertOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Dessert]!
  dessertsConnection(where: DessertWhereInput, orderBy: DessertOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DessertConnection!
  drink(where: DrinkWhereUniqueInput!): Drink
  drinks(where: DrinkWhereInput, orderBy: DrinkOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Drink]!
  drinksConnection(where: DrinkWhereInput, orderBy: DrinkOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DrinkConnection!
  order(where: OrderWhereUniqueInput!): Order
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order]!
  ordersConnection(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderConnection!
  pizza(where: PizzaWhereUniqueInput!): Pizza
  pizzas(where: PizzaWhereInput, orderBy: PizzaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pizza]!
  pizzasConnection(where: PizzaWhereInput, orderBy: PizzaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PizzaConnection!
  promo(where: PromoWhereUniqueInput!): Promo
  promoes(where: PromoWhereInput, orderBy: PromoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Promo]!
  promoesConnection(where: PromoWhereInput, orderBy: PromoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PromoConnection!
  size(where: SizeWhereUniqueInput!): Size
  sizes(where: SizeWhereInput, orderBy: SizeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Size]!
  sizesConnection(where: SizeWhereInput, orderBy: SizeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SizeConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Size {
  id: ID!
  name: String!
  price: Float!
}

type SizeConnection {
  pageInfo: PageInfo!
  edges: [SizeEdge]!
  aggregate: AggregateSize!
}

input SizeCreateInput {
  id: ID
  name: String!
  price: Float!
}

type SizeEdge {
  node: Size!
  cursor: String!
}

enum SizeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  price_ASC
  price_DESC
}

type SizePreviousValues {
  id: ID!
  name: String!
  price: Float!
}

type SizeSubscriptionPayload {
  mutation: MutationType!
  node: Size
  updatedFields: [String!]
  previousValues: SizePreviousValues
}

input SizeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SizeWhereInput
  AND: [SizeSubscriptionWhereInput!]
  OR: [SizeSubscriptionWhereInput!]
  NOT: [SizeSubscriptionWhereInput!]
}

input SizeUpdateInput {
  name: String
  price: Float
}

input SizeUpdateManyMutationInput {
  name: String
  price: Float
}

input SizeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  AND: [SizeWhereInput!]
  OR: [SizeWhereInput!]
  NOT: [SizeWhereInput!]
}

input SizeWhereUniqueInput {
  id: ID
}

type Subscription {
  category(where: CategorySubscriptionWhereInput): CategorySubscriptionPayload
  dessert(where: DessertSubscriptionWhereInput): DessertSubscriptionPayload
  drink(where: DrinkSubscriptionWhereInput): DrinkSubscriptionPayload
  order(where: OrderSubscriptionWhereInput): OrderSubscriptionPayload
  pizza(where: PizzaSubscriptionWhereInput): PizzaSubscriptionPayload
  promo(where: PromoSubscriptionWhereInput): PromoSubscriptionPayload
  size(where: SizeSubscriptionWhereInput): SizeSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  firstname: String!
  lastname: String!
  address: String!
  zip: Int!
  city: String!
  tel: String!
  email: String!
  password: String!
  role: [String!]!
  tokenActivate: String
  tokenResetPassword: String
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  firstname: String!
  lastname: String!
  address: String!
  zip: Int!
  city: String!
  tel: String!
  email: String!
  password: String!
  role: UserCreateroleInput
  tokenActivate: String
  tokenResetPassword: String
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateroleInput {
  set: [String!]
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  firstname_ASC
  firstname_DESC
  lastname_ASC
  lastname_DESC
  address_ASC
  address_DESC
  zip_ASC
  zip_DESC
  city_ASC
  city_DESC
  tel_ASC
  tel_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  tokenActivate_ASC
  tokenActivate_DESC
  tokenResetPassword_ASC
  tokenResetPassword_DESC
}

type UserPreviousValues {
  id: ID!
  firstname: String!
  lastname: String!
  address: String!
  zip: Int!
  city: String!
  tel: String!
  email: String!
  password: String!
  role: [String!]!
  tokenActivate: String
  tokenResetPassword: String
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  firstname: String
  lastname: String
  address: String
  zip: Int
  city: String
  tel: String
  email: String
  password: String
  role: UserUpdateroleInput
  tokenActivate: String
  tokenResetPassword: String
}

input UserUpdateInput {
  firstname: String
  lastname: String
  address: String
  zip: Int
  city: String
  tel: String
  email: String
  password: String
  role: UserUpdateroleInput
  tokenActivate: String
  tokenResetPassword: String
}

input UserUpdateManyMutationInput {
  firstname: String
  lastname: String
  address: String
  zip: Int
  city: String
  tel: String
  email: String
  password: String
  role: UserUpdateroleInput
  tokenActivate: String
  tokenResetPassword: String
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateroleInput {
  set: [String!]
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstname: String
  firstname_not: String
  firstname_in: [String!]
  firstname_not_in: [String!]
  firstname_lt: String
  firstname_lte: String
  firstname_gt: String
  firstname_gte: String
  firstname_contains: String
  firstname_not_contains: String
  firstname_starts_with: String
  firstname_not_starts_with: String
  firstname_ends_with: String
  firstname_not_ends_with: String
  lastname: String
  lastname_not: String
  lastname_in: [String!]
  lastname_not_in: [String!]
  lastname_lt: String
  lastname_lte: String
  lastname_gt: String
  lastname_gte: String
  lastname_contains: String
  lastname_not_contains: String
  lastname_starts_with: String
  lastname_not_starts_with: String
  lastname_ends_with: String
  lastname_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  zip: Int
  zip_not: Int
  zip_in: [Int!]
  zip_not_in: [Int!]
  zip_lt: Int
  zip_lte: Int
  zip_gt: Int
  zip_gte: Int
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  tel: String
  tel_not: String
  tel_in: [String!]
  tel_not_in: [String!]
  tel_lt: String
  tel_lte: String
  tel_gt: String
  tel_gte: String
  tel_contains: String
  tel_not_contains: String
  tel_starts_with: String
  tel_not_starts_with: String
  tel_ends_with: String
  tel_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  tokenActivate: String
  tokenActivate_not: String
  tokenActivate_in: [String!]
  tokenActivate_not_in: [String!]
  tokenActivate_lt: String
  tokenActivate_lte: String
  tokenActivate_gt: String
  tokenActivate_gte: String
  tokenActivate_contains: String
  tokenActivate_not_contains: String
  tokenActivate_starts_with: String
  tokenActivate_not_starts_with: String
  tokenActivate_ends_with: String
  tokenActivate_not_ends_with: String
  tokenResetPassword: String
  tokenResetPassword_not: String
  tokenResetPassword_in: [String!]
  tokenResetPassword_not_in: [String!]
  tokenResetPassword_lt: String
  tokenResetPassword_lte: String
  tokenResetPassword_gt: String
  tokenResetPassword_gte: String
  tokenResetPassword_contains: String
  tokenResetPassword_not_contains: String
  tokenResetPassword_starts_with: String
  tokenResetPassword_not_starts_with: String
  tokenResetPassword_ends_with: String
  tokenResetPassword_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}
`
      }
    